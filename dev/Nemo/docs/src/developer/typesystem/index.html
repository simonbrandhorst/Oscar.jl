<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The type system Â· Oscar.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../../assets/documenter.js"></script><script src="../../../../../siteinfo.js"></script><script src="../../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Oscar.jl</span></div><form class="docs-search" action="../../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../../../">Welcome to Oscar</a></li><li><span class="tocitem">Rings</span><ul><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/rings/">Ring Interface</a></li><li><a class="tocitem" href="../../../../../Rings/integer/">Integers</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Univariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/polynomial_rings/">Univariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/polynomial/">Generic univariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Multivariate Polynomials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/mpolynomial_rings/">Multivariate Polynomial Ring Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/mpolynomial/">Generic sparse distributed multivariate polynomials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Orders</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../../Hecke/docs/src/orders/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../../Hecke/docs/src/orders/orders/">Orders</a></li><li><a class="tocitem" href="../../../../../Hecke/docs/src/orders/elements/">Elements</a></li><li><a class="tocitem" href="../../../../../Hecke/docs/src/orders/ideals/">Ideals</a></li><li><a class="tocitem" href="../../../../../Hecke/docs/src/orders/frac_ideals/">Fractional ideals</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox"/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">Series Rings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/series_rings/">Series Ring Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/series/">Generic power series</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/puiseux/">Generic Puiseux series</a></li><li><a class="tocitem" href="../../series/">Power series and Laurent series</a></li><li><a class="tocitem" href="../../puiseux/">Puiseux series</a></li></ul></li><li><a class="tocitem" href="../../../../../Rings/affine/">Affine Rings</a></li></ul></li><li><span class="tocitem">Fields</span><ul><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/fields/">Field Interface</a></li><li><a class="tocitem" href="../../../../../Rings/rational/">Rationals</a></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Number Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../../Hecke/docs/src/number_fields/intro/">Number Fields</a></li><li><a class="tocitem" href="../../../../../Hecke/docs/src/number_fields/basics/">-</a></li><li><a class="tocitem" href="../../../../../Hecke/docs/src/number_fields/elements/">-</a></li></ul></li><li><a class="tocitem" href="../../../../../Hecke/docs/src/FacElem/">Factored Elements</a></li><li><a class="tocitem" href="../../../../../Hecke/docs/src/class_fields/intro/">Class Field Theory</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/fields/">Field Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/fraction_fields/">Fraction Field Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/fraction/">Generic fraction fields</a></li><li><input class="collapse-toggle" id="menuitem-3-9" type="checkbox"/><label class="tocitem" for="menuitem-3-9"><span class="docs-label">Local Fields</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../padic/">Padics</a></li><li><a class="tocitem" href="../../qadic/">Qadics</a></li></ul></li><li><a class="tocitem" href="../../finitefield/">Finite fields</a></li></ul></li><li><span class="tocitem">Groups</span><ul><li><a class="tocitem" href="../../../../../Groups/groups/">Groups</a></li><li><a class="tocitem" href="../../../../../Hecke/docs/src/abelian/introduction/">Abelian Groups</a></li></ul></li><li><span class="tocitem">Linear Algebra</span><ul><li><a class="tocitem" href="../../../../../Hecke/docs/src/sparse/intro/">Sparse linear algebra</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/matrix_spaces/">Matrix Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/matrix/">Generic matrices</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/matrix_algebras/">Generic matrix algebras</a></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Modules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/module/">Module Interface</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/free_module/">Free Modules and Vector Spaces</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/submodule/">Submodules</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/quotient_module/">Quotient modules</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/direct_sum/">Direct Sums</a></li><li><a class="tocitem" href="../../../../../AbstractAlgebra/docs/src/module_homomorphism/">Module Homomorphisms</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-6" type="checkbox"/><label class="tocitem" for="menuitem-5-6"><span class="docs-label">Quadratic and Hermitian forms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../../../Hecke/docs/src/quad_forms/introduction/">Introduction</a></li><li><a class="tocitem" href="../../../../../Hecke/docs/src/quad_forms/basics/">Basics</a></li><li><a class="tocitem" href="../../../../../Hecke/docs/src/quad_forms/lattices/">Quadratic and hermitian lattices</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>The type system</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The type system</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-type-system"><a class="docs-heading-anchor" href="#The-type-system">The type system</a><a id="The-type-system-1"></a><a class="docs-heading-anchor-permalink" href="#The-type-system" title="Permalink"></a></h1><h2 id="Use-of-Julia-types-in-Nemo"><a class="docs-heading-anchor" href="#Use-of-Julia-types-in-Nemo">Use of Julia types in Nemo</a><a id="Use-of-Julia-types-in-Nemo-1"></a><a class="docs-heading-anchor-permalink" href="#Use-of-Julia-types-in-Nemo" title="Permalink"></a></h2><h3 id="Concrete-and-abstract-types"><a class="docs-heading-anchor" href="#Concrete-and-abstract-types">Concrete and abstract types</a><a id="Concrete-and-abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Concrete-and-abstract-types" title="Permalink"></a></h3><p>Julia does not provide a traditional class/inheritance approach to programming. Instead, the basic unit of its object oriented approach is the type definition (<code>struct</code> and <code>mutable struct</code>) and inheritance exists only on the function side of the language rather than data side. Julia provides a rich system of abstract types and unions on the data side and multimethods on the function side to effect this.</p><p>For example Julia&#39;s <code>Number</code> type is an abstract type containing all concrete types that behave like numbers, e.g. <code>Int64</code>, <code>Float64</code>, and so on.</p><p>Abstract types can also belong to other abstract types, forming a tree of abstract types.</p><p>In Nemo the most important abstract types are <code>Ring</code> and <code>Field</code>, with the latter belonging to the former so that all fields are rings, and the abstract types <code>RingElem</code> and <code>FieldElem</code> for the objects that represent elements of rings and fields, again with the latter abstract type belonging to the former.</p><p>Because this hierarchy of abstract types must form a tree, Julia is strictly speaking single inheritance, as each concrete and abstract type can belong to at most one other abstract type. For example, one could not have a diamond of abstract types with <code>ExactField</code> belonging to both <code>Field</code> and <code>ExactRing</code>.</p><h3 id="Recovering-aspects-of-multiple-inheritance-in-Nemo"><a class="docs-heading-anchor" href="#Recovering-aspects-of-multiple-inheritance-in-Nemo">Recovering aspects of multiple inheritance in Nemo</a><a id="Recovering-aspects-of-multiple-inheritance-in-Nemo-1"></a><a class="docs-heading-anchor-permalink" href="#Recovering-aspects-of-multiple-inheritance-in-Nemo" title="Permalink"></a></h3><p>Various possibilities exist to get around the limitation that abstract types must form a &#39;tree&#39; in Nemo and AbstractAlgebra.</p><p>One such possibility is union types. If a function should accept one of a number of concrete or abstract types that can&#39;t all be made to belong to a single abstract type due to this limitation then one can use a union type.</p><p>For example, Nemo defines <code>RingElement</code> to be a union of <code>RingElem</code> and all the Julia standard types which behave like ring elements, e.g. all <code>Integer</code> types and types of rationals with <code>Integer</code> components.</p><p>A second feature we make use of in Nemo is parameterised types. Each concrete and abstract type can take one or more parameters. These parameter can be any other type, either concrete or abstract. For example, in Julia <code>Rational{T}</code> is for rationals with numerator and denominator of type <code>T</code>.</p><p>A great deal of control over parameterised types is possible, e.g. one can restrict the type parameter <code>T</code> using a <code>where</code> clause, e.g. to write a function that accepts all rational types with integer components of the same type one can use the type <code>Rational{T} where T &lt;: Integer</code>.</p><p>Nemo makes use of such parameterised types for generic ring constructions such as generic polynomial rings and matrices over a given base ring. The type of the elements of the base ring is substituted for the parameter <code>T</code> in any concrete instantiation of the types <code>Poly{T}</code> and <code>Mat{T}</code>, which are defined in AbstractAlgebra in <code>src/generic/GenericTypes.jl</code>.</p><p>The totality of all univariate polynomial types, including those of generic <code>Poly{T}</code> types and those coming from C libraries (such as <code>fmpz_poly</code>), is represented by the abstract type <code>PolyElem{T}</code> which in turn belongs to <code>RingElem</code>, both defined in AbstractAlgebra in <code>src/AbstractTypes.jl</code>.</p><p>Similarly, the totality of all matrix types, including explicit C types like <code>fmpz_mat</code> and the generic <code>Mat{T}</code> types is given by the abstract type <code>MatElem{T}</code>, again defined in AbstractAlgebra in <code>src/AbstractTypes.jl</code>.</p><p>This hierarchy of types allows one to write functions at any level, e.g. for all univariate polynomial types, just those with a given base type <code>T</code>, or for a specific concrete type corresponding to just one kind of univariate polynomial.</p><p>A third possibility to get around the single inheritance limitation of Julia is type traits. There is currently no explicit compiler/language support for traits, however various implementations exist that make use of type parameters in tricky ways. This allows one to add &#39;traits&#39; to types, so long as those traits can be expressed as types. In this way, types can have multiple &#39;properties&#39; at the same time, instead of belonging to just a single abstract type.</p><p>Nemo does not currently use type traits, though the map types in Nemo do make use of a custom analogue of this.</p><p>Note that unlike class based systems that dispatch on the type of a (sometimes implicit) <code>this</code> or `self&#39; parameter, Julia methods dispatch on the type of all arguments. This is a natural fit for mathematics where all sorts of ad hoc left and right operations may be required.</p><h3 id="Encapsulation,-maps-and-runtime-flags"><a class="docs-heading-anchor" href="#Encapsulation,-maps-and-runtime-flags">Encapsulation, maps and runtime flags</a><a id="Encapsulation,-maps-and-runtime-flags-1"></a><a class="docs-heading-anchor-permalink" href="#Encapsulation,-maps-and-runtime-flags" title="Permalink"></a></h3><p>One limitation of the Julia approach is that the type of an object cannot be changed at runtime. For example one might like to insist that a given ring is in fact a field. There are three standard ways to handle this in Julia.</p><p>The first approach is to encapsulate the object in another object which does have the desired type. The second approach is to map the object to a different one of the required type (e.g. by applying a morphism). The third approach is to introduce data fields in the original type which can be changed at runtime, unlike its type. All three approaches come with downsides. </p><p>Encapsulation can be time consuming for the developer as methods which applied to the original object do not automatically apply to the encapsulated object. One can write methods which do, but this is not automatic.</p><p>Application of a map may come with a performance penalty and may be difficult for the user to navigate. Moreover, mutation of the resulting object does not result in mutation of the original object.</p><p>The third option of adding runtime data fields essentially takes one back to writing a (possibly bug ridden) interpreter. It relies on the developer  implementing outer methods that make use of hand written control statements to determine which of a range of inner methods should be applied to the object. This misses the benefits of one of the main defining features of Julia, namely its multimethod system and can also make introspection more difficult.</p><p>Nemo does not apply any of these three approaches widely at present, though information which can only be known at runtime such as whether a ring is Euclidean will eventually have to be encoded using one of these three methods.</p><h3 id="Nemo&#39;s-custom-map-types"><a class="docs-heading-anchor" href="#Nemo&#39;s-custom-map-types">Nemo&#39;s custom map types</a><a id="Nemo&#39;s-custom-map-types-1"></a><a class="docs-heading-anchor-permalink" href="#Nemo&#39;s-custom-map-types" title="Permalink"></a></h3><p>It makes sense that map types in Nemo should be parameterised by the element types of both the domain and codomain of the map, and of course all maps in the system should somehow belong to an abstract type <code>Map</code>.</p><p>This leads one to consider a two parameter system of types <code>Map{D, C}</code> where <code>D</code> and <code>C</code> are the domain and codomain types respectively.</p><p>One may also wish to implement various types of map, e.g. linear maps (where the map contains a matrix representing the map) or functional maps (where the map is implemented by a Julia function) and so on. Notionally one imagines doing this with a hierarchy of two parameter abstract types all ultimately belonging to <code>Map{D, C}</code> as the root of the tree.</p><p>This approach begins to break down when constructions from homological algebra begin to be applied to maps. In such cases, the maps themselves are the object of study and functions may be applied to maps to produce other maps.</p><p>The simplest such function is composition. In a system where composition of maps always results in a map of the same type, no problem arises with the straightforward approach outlined above.</p><p>However, for various reasons (including performance) it may not be desirable or even possible to construct a composition of two given maps using the same representation as the original maps. This means that the result of composing two maps of the same type may be a map of a different type, e.g. in the worst case a general composition type.</p><p>This problem makes many homological and category theoretic operations on maps difficult or impossible to implement.</p><p>Other operations which may be desirable to implement are caching of maps (e.g. where the map is extremely time consuming to compute, such as discrete logarithms) and attaching category theoretic information to maps. Such operations can be effected by encapsulating existing maps in objects containing the extra information, e.g. a cache or a category. However all the methods that applied to the original map objects now no longer apply to the encapsulated objects.</p><p>To work around these limitations Nemo implements a four parameter <code>Map</code> type, <code>Map{D, C, T, U}</code>.</p><p>The first two parameters are the domain and codomain types as discussed above.</p><p>The parameter <code>T</code> is a &quot;map class&quot; which is itself an abstract type existing in a hierarchy of abstract types. This parameter is best thought of as a trait, independent of the hierarchy of abstract types belonging to <code>Map</code>, giving additional flexibility to the map types in the system.</p><p>For example, <code>T</code> may be set to <code>LinearMap</code> or <code>FunctionalMap</code>. This may be useful if one wishes to distinguish maps in other ways, e.g. whether they are homomorphisms, isomorphisms, maps with section or retraction etc. As usual, offering traits partially gets around the single inheritance problem.</p><p>The final parameter <code>U</code> is used to allow maps of a given type <code>U</code> to be composed and still result in a map of type <code>U</code>, even though the concrete type of the composition is different to that of the original maps. Methods can be written for all maps of type <code>U</code> by matching this parameter, rather than matching on the concrete type <code>U</code> of the original maps.</p><p>For example, two maps with concrete type <code>MyRingHomomorphism</code> would belong to <code>Map{D, C, T, MyRingHomomorphism}</code> as would any composition of such maps, even if the concrete type of the composition was not a <code>MyRingHomomorphism</code>.</p><p>Naturally four parameter types are rather unwieldy and so various helper functions are provided to compute four parameter map types. In the first instance one still has the type <code>Map{D, C}</code> which will give the union of all map types whose first two parameters are <code>D</code> and <code>C</code>, and where the remaining two parameters are arbitrary.</p><p>However one can also pass a map class or a concrete type <code>U</code> to a <code>Map</code> function to compute the class of all maps of the given map class or type..</p><p>For example, to write a function which accepts all maps of &quot;type&quot; <code>MyRingHomomorphism</code>, including all compositions of such maps, one inserts <code>Map(MyRingHomomorphism)</code> in place of the type, e.g.</p><pre><code class="language-julia">function myfun(f::Map(MyRingHomomorphism))</code></pre><p>Note the parentheses here, rather than curly braces; it&#39;s a function to compute a type! Now the function <code>myfun</code> will accept any map type whose fourth parameter <code>U</code> is set to <code>MyRingHomomorphism</code>.</p><p>This four parameter system is flexible, but may need to be expanded in the future. For example it may be useful to have more than one trait <code>T</code>. This could be achieved either by making <code>T</code> a tuple of traits or by introducing a parameterised <code>MapTrait</code> type which can be placed at that location. Naturally the <code>Map</code> functions for computing the four parameter types will have to be similarly expanded to make it easier for the user.</p><p>The map type system is currently considered experimental and our observation so far is that it is not intuitive for developers.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 26 February 2021 15:20">Friday 26 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
